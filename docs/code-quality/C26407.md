---
title: C26407 | Microsoft Docs
ms.custom: 
ms.date: 07/21/2017
ms.reviewer: 
ms.suite: 
ms.technology: vs-ide-code-analysis
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords: C26407
helpviewer_keywords: C26407
ms.assetid: 5539907a-bfa0-40db-82a6-b860c97209e1
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload: multiple
ms.openlocfilehash: 81de385f2d30a08b288b9c79c3fda9f808bc3128
ms.sourcegitcommit: 32f1a690fc445f9586d53698fc82c7debd784eeb
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 12/22/2017
---
# <a name="c26407-dontheapallocateunnecessarily"></a>C26407 DONT_HEAP_ALLOCATE_UNNECESSARILY
Biz yerel ayırmalarının ortak desenler örneğin algılamaya işaretçileri gereksiz kullanımını önlemek için ne zaman new işleci için bir çağrı sonucunu bir yerel değişken ve daha sonra açıkça silinen depolanır. Bu kural R.5 destekler: *tercih kapsamlı nesneler, yığın-gereksiz yere Ayır yok*. Önerilen düzeltme RAII türü yerine ham işaretçi kaynaklarla ilgilidir izin kullanmaktır. Bir ayırma tek bir nesne ise, açıkça gereksiz olabilir ve bir yerel değişken nesnenin türü daha iyi çalışır.

## <a name="remarks"></a>Açıklamalar
- Uyarıların sayısını azaltmak için bu deseni yalnızca sahibi işaretçileri algılandı. Bu nedenle, sahipleri düzgün olarak işaretlemek gerekli olan ilk. Biz kolayca bundan böyle senaryo desteklemek Müşterilerden aldığımız geri bildirim, ham işaretçileri kapsayacak şekilde genişletebilirsiniz.
- Kapsamlı nesne terimi biraz yanıltıcı olabilir, ancak genel, yaşam süresi otomatik olarak yönetilen bir yerel değişken ya da dinamik kaynakları yönetir bir akıllı nesnesi kullanarak önerdiğimiz olur. Yığın ayırmaları indirmelere, akıllı nesneler olabilir, ancak kodda açık değil.
- (Bu, genellikle dinamik arabellekleri için gerekli olan) dizi ayırma üzerinde uyarı başlatılır, düzeltme standart kapsayıcılar kullanma olabilir veya `std::unique_pointer<T[]>`.
- Desen burada bir ayırma söyleyin, atandığı olaylarda genel değişkeni uyarma için yalnızca yerel değişkenleri algıladı ve aynı işlevde silindi.

## <a name="example-1-unnecessary-object-allocation-on-heap"></a>Örnek 1: Gereksiz nesne ayırma yığında
```cpp
auto tracer = new Tracer();
ScanObjects(tracer);
delete tracer;  // C26407
```

## <a name="example-2-unnecessary-object-allocation-on-heap-fixed-with-local-object"></a>Örnek 2: Gereksiz nesne ayırma (yerel nesnesiyle sabit) yığında
```cpp
Tracer tracer;  // OK
ScanObjects(&tracer);
```

## <a name="example-3-unnecessary-buffer-allocation-on-heap"></a>Örnek 3: Gereksiz arabellek ayırma yığında
```cpp
auto value = new char[maxValueSize];
if (ReadSetting(name, value, maxValueSize))
    CheckValue(value);
delete[] value; // C26407
```
## <a name="example-4-unnecessary-buffer-allocation-on-the-heap-fixed-with-container"></a>Örnek 4: Gereksiz arabellek ayırma (kapsayıcı ile sabit) yığında
```cpp
auto value = std::vector<char>(maxValueSize); // OK
if (ReadSetting(name, value.data(), maxValueSize))
    CheckValue(value.data());
```
