---
title: C6211
ms.date: 11/04/2016
ms.prod: visual-studio-dev15
ms.technology: vs-ide-code-analysis
ms.topic: reference
f1_keywords:
- C6211
helpviewer_keywords:
- C6211
ms.assetid: 9b68243b-534c-4a05-b789-bb155dfcba1e
author: mikeblome
ms.author: mblome
manager: wpickett
ms.workload:
- multiple
ms.openlocfilehash: 7b546097b1238f1d976151a62d4e4ae644c7f297
ms.sourcegitcommit: 6944ceb7193d410a2a913ecee6f40c6e87e8a54b
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 09/06/2018
ms.locfileid: "35677314"
---
# <a name="c6211"></a>C6211
Uyarı C6211: bellek sızıntısına yol açıyor \<işaretçi > bir özel durum nedeniyle. Belleği temizlemek için yerel catch bloğunu kullanmayı düşünün

 Bu uyarı, bir özel durum oluştuğunda ayrılan belleği serbest bırakıldı değil gösterir. Yolun sonuna deyimi bir özel durum. Çözümleyicisi denetler için bu koşul yalnızca `_Analysis_mode_(_Analysis_local_leak_checks_)` SAL ek açıklaması belirtildiğinde. Varsayılan olarak, bu ek bilgi Windows çekirdek modu (sürücü) kodu için belirtilir. SAL açıklamaları hakkında daha fazla bilgi için bkz. [C/C++ kod hatalarını azaltmak için SAL ek açıklamalarını kullanarak](../code-quality/using-sal-annotations-to-reduce-c-cpp-code-defects.md).

## <a name="example"></a>Örnek
 Aşağıdaki kod bu bir özel durum ikinci ayırma sırasında ve dolayısıyla sızıntısı ilk ayırma durum oluşturulabilir uyarıyı oluşturur çünkü veya bir yere tarafından temsil edilen kodda özel durum "`code ...`" açıklama ve dolayısıyla Her iki ayırma sızıntı.

```cpp
// cl.exe /analyze /c /EHsc /nologo /W4 
#include <sal.h>

_Analysis_mode_(_Analysis_local_leak_checks_) 
void f( )
{
    char *p1 = new char[10];
    char *p2 = new char[10];

    // code ...

    delete[] p2;
    delete[] p1;
}

```

 Aynı ayırma işlevlerini kullanın ve bu sorunu düzeltmek için özel durum işleyicisi ekleyin:

```cpp
// cl.exe /analyze /c /EHsc /nologo /W4
#include <sal.h>
#include <new>
#include <iostream>
using namespace std;

_Analysis_mode_(_Analysis_local_leak_checks_) 

void f()
{
    char *p1 = nullptr; 
    char *p2 = nullptr;

    try
    {
        p1 = new char[10];
        p2 = new char[10];

        // code ...

        delete [] p2;
        delete [] p1;
    }
    catch (const bad_alloc& ba)
    {
        cout << ba.what() << endl;
        delete [] p2;
        delete [] p1;
    }
    // code ...
}

```

 Bu tür olası sızıntılarını tamamen önlemek için C++ Standart Şablon kitaplığı (STL) tarafından sağlanan mekanizmalarını kullanın. Bunlar [shared_ptr](/cpp/standard-library/shared-ptr-class), [unique_ptr](/cpp/standard-library/unique-ptr-class), ve [vektör](/cpp/standard-library/vector). Daha fazla bilgi için [akıllı işaretçiler](/cpp/cpp/smart-pointers-modern-cpp) ve [C++ Standart Kitaplığı](/cpp/standard-library/cpp-standard-library-reference).

```cpp
// cl.exe /analyze /c /EHsc /nologo /W4
#include <sal.h>
#include <vector>
#include <memory>

using namespace std;

_Analysis_mode_(_Analysis_local_leak_checks_) 

void f( )
{
    // use 10-element vectors in place of char[10]
    vector<char> v1;
    vector<char> v2;

    for (int i=0; i<10; ++i) {
        v1.push_back('a');
        v2.push_back('b');
    }
    // code ...

    // use unique_ptr if you still want char[10]
    unique_ptr<char[]> a1(new char[10]);
    unique_ptr<char[]> a2(new char[10]);

    // code ...

    // No need for delete; vector and unique_ptr 
    // clean up when out of scope.
}

```

## <a name="see-also"></a>Ayrıca Bkz.
 [C++ Özel Durum İşleme](/cpp/cpp/cpp-exception-handling)